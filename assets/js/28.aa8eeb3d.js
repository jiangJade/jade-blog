(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{390:function(t,s,e){"use strict";e.r(s);var v=e(3),_=Object(v.a)({},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"什么是重绘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是重绘","aria-hidden":"true"}},[t._v("#")]),t._v(" 什么是重绘")]),t._v(" "),e("p",[t._v("当元素的一部分属性发生变化，如外观背景色不会引起布局变化而需要重新渲染的过程叫做重绘.")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",[t._v("例如（改变样式）")])]),t._v(" "),e("h2",{attrs:{id:"什么是回流？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是回流？","aria-hidden":"true"}},[t._v("#")]),t._v(" 什么是回流？")]),t._v(" "),e("p",[t._v("当render树中的一部分或者全部因为"),e("font",{attrs:{face:"微软雅黑",size:"5"}},[t._v("大小边距")]),t._v("等问题发生改变而需要重建的过程叫做回流.")],1),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",[t._v("（改变大小）")])]),t._v(" "),e("h3",{attrs:{id:"_1、回流发生条件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、回流发生条件","aria-hidden":"true"}},[t._v("#")]),t._v(" 1、回流发生条件")]),t._v(" "),e("p",[t._v("当页面布局和几何属性改变时就需要回流。下述情况会发生浏览器回流：")]),t._v(" "),e("div",{staticClass:"custom-block warning"},[e("p",[t._v("（1）添加或者删除可见的DOM元素；")]),t._v(" "),e("p",[t._v("（2）元素位置改变；")]),t._v(" "),e("p",[t._v("（3）元素尺寸改变——边距、填充、边框、宽度和高度")]),t._v(" "),e("p",[t._v("（4）内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；")]),t._v(" "),e("p",[t._v("（5）页面渲染初始化；")]),t._v(" "),e("p",[t._v("（6）浏览器窗口尺寸改变——resize事件发生时；")])]),t._v(" "),e("p",[t._v("浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，\n等队列中的操作到了一定的数量或者到了一定的时间间隔，\n浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。")]),t._v(" "),e("div",{staticClass:"custom-block warning"},[e("p",[t._v("下面这些操作会让浏览器flush队列\n（1）offsetTop, offsetLeft, offsetWidth, offsetHeight")]),t._v(" "),e("p",[t._v("（2） scrollTop/Left/Width/Height")]),t._v(" "),e("p",[t._v("（3）clientTop/Left/Width/Height")]),t._v(" "),e("p",[t._v("（4）width,height")]),t._v(" "),e("p",[t._v("（5）请求了getComputedStyle(), 或者 IE的 currentStyle")])]),t._v(" "),e("h3",{attrs:{id:"如何减少回流和重绘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何减少回流和重绘","aria-hidden":"true"}},[t._v("#")]),t._v(" 如何减少回流和重绘")]),t._v(" "),e("p",[t._v("1、减少回流和重绘其实就是需要减少对render tree的操作（合并多次多DOM和样式的修改），\n并减少对一些样式信息的请求，尽量利用好浏览器的优化策略。")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",[t._v("（1）添加css样式而不是利用js控制样式（我就是想到这种办法解决回流问题的）")]),t._v(" "),e("p",[t._v("（2）尽量将需要改变DOM的操作一次完成")]),t._v(" "),e("p",[t._v("（3）直接改变className，如果动态改变样式，则使用cssText（考虑没有优化的浏览器）")]),t._v(" "),e("p",[t._v("（4）不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存")]),t._v(" "),e("p",[t._v("（5）让元素脱离动画流，减少回流的Render Tree的规模")]),t._v(" "),e("p",[t._v("（6）将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位；")]),t._v(" "),e("p",[t._v("（7）尽量不要使用表格布局，如果没有定宽表格一列的宽度由最宽的一列决定，那么很可能在最后一行的宽度超出之前的列宽，引起整体回流造成table可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间")])])])},[],!1,null,null,null);s.default=_.exports}}]);