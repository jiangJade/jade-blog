---
title: 正则表达式——语法篇
date: 2018-08-16
tags:
  - js
categories:
  - js
---

## 1 正则是什么？

:::tip
正则就是用有限的符号，表达无限的序列，殆已！
:::

```js
// 匹配数字后面以英文逗号隔开 这里会有一个问题导致内存泄漏
// 就是d$这个￥符 如果不是英文逗号 比如输入一个空格 这会导致回溯过多 然后直接卡死
const regExpRull = /^(\d+,?)*(?=\d$)/;
if (!value || regExpRull.test(value)) {
  return Promise.resolve();
}
```

&emsp;&emsp;正则表达式的语法一般如下，两条斜线中间是正则主体，这部分可以有很多字符组成；<font color="#2E6CEA">i 部分是修饰符，i 的意思表示忽略大小写</font>

```
/^abc/i
```

## 2 正则定义了很多特殊意义的字符，有名词，量词，谓词等，下面逐一介绍

### 1 简单字符

&emsp;&emsp;没有特殊意义的字符都是简单字符，简单字符就代表自身，绝大部分字符都是简单字符，举个例子

```
/cmd/ // 匹配 cmd
/123/ // 匹配 123
/-_-/ // 匹配 -_-
/中文/ // 匹配 中文
```

### 2 转义字符

\是转义字符，其后面的字符会代表不同的意思，转义字符主要有三个作用：

:::tip
第一种，是为了匹配不方便显示的特殊字符，比如换行，tab 符号等

第二种，正则中预先定义了一些代表特殊意义的字符，比如\w 等

第三种，在正则中某些字符有特殊含义(比如下面说到的)，转义字符可以让其显示自身的含义
:::
&emsp;&emsp;下面是常用转义字符列表：

| 规则   |                     说明                     |
| ------ | :------------------------------------------: |
| \n     |                  匹配换行符                  |
| \r     |                  匹配回车符                  |
| \t     |          匹配制表符，也就是 tab 键           |
| \v     |        匹配垂直制表符(表示几个换行符)        |
| \x20   |    20 是 2 位 16 进制数字，代表对应的字符    |
| \u002B |   002B 是 4 位 16 进制数字，代表对应的字符   |
| \w     |      匹配任何一个字母或者数字或者下划线      |
| \W     | 匹配任何一个字母或者数字或者下划线以外的字符 |
| \s     |         匹配空白字符，如空格，tab 等         |
| \S     |                匹配非空白字符                |
| \d     |              匹配数字字符，0~9               |
| \D     |                匹配非数字字符                |
| \b     |                匹配单词的边界                |
| \B     |                匹配非单词边界                |
| \\     |                  匹配\本身                   |

### 3 字符集和

&emsp;&emsp;有时我们需要匹配一类字符，字符集可以实现这个功能，字符集的语法用[]分隔，下面的代码能够匹配 g 或 a 或 d

```
[gad]
```

&emsp;&emsp;如果要表示字符很多，可以使用-表示一个范围内的字符，下面两个功能相同

```
[0123456789]
[0-9]
```

&emsp;&emsp;在前面添加^，可表示非的意思，下面的代码能够匹配 gad 之外的任意字符

```
[^gad]
```

&emsp;&emsp;其实正则还内置了一些字符集，在上面的转义字符有提到，下面给出内置字符集对应的自定义字符集

.匹配除了换行符（\n）以外的任意一个字符 = [^\n]
. \w = [0-9a-zA-Z_]
. \W = [^0-9a-za-z_]
. \s = [ \t\n\v]
. \S = [^ \t\n\v]
. \d = [0-9]
. \D = [^0-9]

## 4 量词

&emsp;&emsp;如果我们有三个苹果，我们可以说自己有个 3 个苹果，也可以说有一个苹果，一个苹果，一个苹果，每种语言都有量词的概念

&emsp;&emsp;如果需要匹配多次某个字符，正则也提供了量词的功能，正则中的量词有多个，如?、+、\*、{n}、{m,n}、{m,}

&emsp;&emsp;{n}匹配 n 次，比如 a{2}，匹配 aa

&emsp;&emsp;{m, n}匹配 m-n 次，优先匹配 n 次，比如 a{1,3}，可以匹配 aaa、aa、a

&emsp;&emsp;{m,}匹配 m-∞ 次，优先匹配 ∞ 次，比如 a{1,}，可以匹配 aaaa...

&emsp;&emsp;?匹配 0 次或 1 次，优先匹配 1 次，相当于{0,1}

&emsp;&emsp;+匹配 1-n 次，优先匹配 n 次，相当于{1,}

&emsp;&emsp;\*匹配 0-n 次，优先匹配 n 次，相当于{0,}

&emsp;&emsp;正则默认和人心一样是贪婪的，也就是常说的贪婪模式，凡是表示范围的量词，都优先匹配上限而不是下限

## 5 字符边界

&emsp;&emsp;有时我们会有边界的匹配要求，比如以 xxx 开头，以 xxx 结尾

&emsp;&emsp;^在[]外表示匹配开头的意思

:::tip
^abc // 可以匹配 abc，但是不能匹配 aabc
:::

&emsp;&emsp;$表示匹配结尾的意思
:::tip
abc$ // 可以匹配 abc，但是不能匹配 abcc
:::

&emsp;&emsp;上面提到的\b 表示单词的边界

:::tip
abc\b // 可以匹配 abc ，但是不能匹配 abcc
:::

## 6 选择表达式

有时我们想匹配 x 或者 y，如果 x 和 y 是单个字符，可以使用字符集，[abc]可以匹配 a 或 b 或 c，如果 x 和 y 是多个字符，字符集就无能为力了，此时就要用到分组

正则中用|来表示分组，a|b 表示匹配 a 或者 b 的意思

:::tip
123|456|789 // 匹配 123 或 456 或 789
:::

## 7 分组与引用

分组是正则中非常强大的一个功能，可以让上面提到的量词作用于一组字符，而非单个字符，分组的语法是圆括号包裹(xxx)

:::tip
(abc){2} // 匹配 abcabc
分组不能放在[]中，但分组中还可以使用选择表达式
(123|456){2} // 匹配 123123、456456、123456、456123
:::

和分组相关的概念还有一个捕获分组和非捕获分组，分组默认都是捕获的，在分组的(后面添加?:可以让分组变为非捕获分组，非捕获分组可以提高性能和简化逻辑

:::tip
'123'.match(/(?:123)/) // 返回 ['123']
'123'.match(/(123)/) // 返回 ['123', '123']
:::

和分组相关的另一个概念是引用，比如在匹配 html 标签时，通常希望<xxx></xxx>后面的 xxx 能够和前面保持一致

引用的语法是\数字，数字代表引用前面第几个捕获分组，注意非捕获分组不能被引用

:::tip
<([a-z]+)><\/\1> // 可以匹配 `<span></span>` 或 `<div></div>`等
:::

## 8 预搜索

如果你想匹配 xxx 前不能是 yyy，或者 xxx 后不能是 yyy，那就要用到预搜索

js 只支持正向预搜索，也就是 xxx 后面必须是 yyy，或者 xxx 后面不能是 yyy

:::tip
1(?=2) // 可以匹配 12，不能匹配 22
1(?!2) // 可有匹配 22，不能匹配 12
:::

修饰符
默认正则是区分大小写，这可能并不是我们想要的，正则提供了修饰符的功能，修复的语法如下
:::tip
/xxx/gi // 最后面的 g 和 i 就是两个修饰符
g 正则遇到第一个匹配的字符就会结束，加上全局修复符，可以让其匹配到结束

i 正则默认是区分大小写的，i 可以忽略大小写

m 正则默认情况下，^和$只能匹配字符串的开始和结尾，m修饰符可以让^和$匹配行首和行尾，不理解就看例子

/jing$/ // 能够匹配 'yanhaijing，不能匹配 'yanhaijing\n'
/jing$/m // 能够匹配 'yanhaijing， 能够匹配 'yanhaijing\n'

/^jing/ // 能够匹配 'jing'，不能匹配 '\njing'
/^jing/m // 能够匹配 'jing'，能够匹配 '\njing'
:::
