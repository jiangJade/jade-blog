(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{546:function(t,s,v){"use strict";v.r(s);var _=v(4),e=Object(_.a)({},(function(){var t=this,s=t.$createElement,v=t._self._c||s;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"什么是重绘"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是重绘"}},[t._v("#")]),t._v(" 什么是重绘")]),t._v(" "),v("p",[t._v("当元素的一部分属性发生变化，如外观背景色不会引起布局变化而需要重新渲染的过程叫做重绘.")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",[t._v("例如（改变样式）")])]),t._v(" "),v("h2",{attrs:{id:"什么是回流？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是回流？"}},[t._v("#")]),t._v(" 什么是回流？")]),t._v(" "),v("p",[t._v("当 render 树中的一部分或者全部因为"),v("font",{attrs:{face:"微软雅黑",size:"5"}},[t._v("大小边距")]),t._v("等问题发生改变而需要重建的过程叫做回流.")],1),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",[t._v("（改变大小）")])]),t._v(" "),v("h3",{attrs:{id:"_1、回流发生条件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、回流发生条件"}},[t._v("#")]),t._v(" 1、回流发生条件")]),t._v(" "),v("p",[t._v("当页面布局和几何属性改变时就需要回流。下述情况会发生浏览器回流：")]),t._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",[t._v("（1）添加或者删除可见的 DOM 元素；")]),t._v(" "),v("p",[t._v("（2）元素位置改变；")]),t._v(" "),v("p",[t._v("（3）元素尺寸改变——边距、填充、边框、宽度和高度")]),t._v(" "),v("p",[t._v("（4）内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；")]),t._v(" "),v("p",[t._v("（5）页面渲染初始化；")]),t._v(" "),v("p",[t._v("（6）浏览器窗口尺寸改变——resize 事件发生时；")])]),t._v(" "),v("p",[t._v("浏览器会维护 1 个队列，把所有会引起回流、重绘的操作放入这个队列，\n等队列中的操作到了一定的数量或者到了一定的时间间隔，\n浏览器就会 flush 队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。")]),t._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",[t._v("下面这些操作会让浏览器 flush 队列\n（1）offsetTop, offsetLeft, offsetWidth, offsetHeight")]),t._v(" "),v("p",[t._v("（2） scrollTop/Left/Width/Height")]),t._v(" "),v("p",[t._v("（3）clientTop/Left/Width/Height")]),t._v(" "),v("p",[t._v("（4）width,height")]),t._v(" "),v("p",[t._v("（5）请求了 getComputedStyle(), 或者 IE 的 currentStyle")])]),t._v(" "),v("h3",{attrs:{id:"如何减少回流和重绘"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何减少回流和重绘"}},[t._v("#")]),t._v(" 如何减少回流和重绘")]),t._v(" "),v("p",[t._v("1、减少回流和重绘其实就是需要减少对 render tree 的操作（合并多次多 DOM 和样式的修改），\n并减少对一些样式信息的请求，尽量利用好浏览器的优化策略。")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",[t._v("（1）添加 css 样式而不是利用 js 控制样式（我就是想到这种办法解决回流问题的）")]),t._v(" "),v("p",[t._v("（2）尽量将需要改变 DOM 的操作一次完成")]),t._v(" "),v("p",[t._v("（3）直接改变 className，如果动态改变样式，则使用 cssText（考虑没有优化的浏览器）")]),t._v(" "),v("p",[t._v("（4）不要经常访问会引起浏览器 flush 队列的属性，如果你确实要访问，利用缓存")]),t._v(" "),v("p",[t._v("（5）让元素脱离动画流，减少回流的 Render Tree 的规模")]),t._v(" "),v("p",[t._v("（6）将需要多次重排的元素，position 属性设为 absolute 或 fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位；")]),t._v(" "),v("p",[t._v("（7）尽量不要使用表格布局，如果没有定宽表格一列的宽度由最宽的一列决定，那么很可能在最后一行的宽度超出之前的列宽，引起整体回流造成 table 可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花 3 倍于同等元素的时间")])])])}),[],!1,null,null,null);s.default=e.exports}}]);