(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{552:function(n,a,e){"use strict";e.r(a);var t=e(4),r=Object(t.a)({},(function(){var n=this,a=n.$createElement,e=n._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("几乎所有编程语言最基本的功能之一，就是能够储存变量当中的值，并且能在之后对这个 值进行访问或修改。\n在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编 译”。")]),n._v(" "),e("ol",[e("li",[e("p",[n._v("分词/词法分析（Tokenizing/Lexing）•\n这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代 码块被称为词法单元（token）。例如，考虑程序 var a = 2;。这段程序通常会被分解成 为下面这些词法单元：var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在 这门语言中是否具有意义。\n(1) 分词（tokenizing）和词法分析（Lexing）之间的区别是非常微妙、晦涩的，主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简 单来说，如果词法单元生成器在判断 a 是一个独立的词法单元还是其他词法 单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法 分析。")])]),n._v(" "),e("li",[e("p",[n._v("解析/语法分析（Parsing）•\n这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法 结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。")])]),n._v(" "),e("li",[e("p",[n._v("代码生成\n将 AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息 息相关。 抛开具体细节，简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指 令，用来创建一个叫作 a 的变量（包括分配内存等），并将一个值储存在 a 中。")]),n._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",[n._v("JavaScript 的编译过程不是发生在构建之前的，对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时 间内\n引擎\n从头到尾负责整个 JavaScript 程序的编译及执行过程。\n编译器\n引擎的好朋友之一，负责语法分析及代码生成等脏活累活（详见前一节的内容）。\n作用域\n引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查 询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。")])]),n._v(" "),e("p",[n._v("引擎会为变量 a 进行 LHS 查询。另外一个查找的类型叫作 RHS。\nconsole.log( a );\n其中对 a 的引用是一个 RHS 引用，因为这里 a 并没有赋予任何值。相应地，需要查找并取 得 a 的值，这样才能将值传递给 console.log(..)。\n相比之下，例如：\na = 2;\n这里对 a 的引用则是 LHS 引用，因为实际上我们并不关心当前的值是什么，只是想要为 = 2 这个赋值操作找到一个目标。")]),n._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",[n._v("LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“= 赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最 好将其理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头 （RHS）”。")])]),n._v(" "),e("p",[n._v("作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到， 就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都 会停止。")])]),n._v(" "),e("li",[e("p",[n._v("为什么区分 LHS 和 RHS 是一件重要的事情？\n因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行 为是不一样的。\n严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询 失败时类似的 ReferenceError 异常。")])])]),n._v(" "),e("p",[n._v("接下来，如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作， 比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的 属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError。")]),n._v(" "),e("p",[n._v("ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对 结果的操作是非法或不合理的。")]),n._v(" "),e("p",[n._v("小结：作用域就是一套规则，规定在什么地方以及何时正确的查找变量")])])}),[],!1,null,null,null);a.default=r.exports}}]);