(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{577:function(t,a,e){"use strict";e.r(a);var s=e(4),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"从浏览器地址栏输入url到返回请求的过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从浏览器地址栏输入url到返回请求的过程"}},[t._v("#")]),t._v(" 从浏览器地址栏输入url到返回请求的过程")]),t._v(" "),e("p",[t._v("先进行dns域名解析")]),t._v(" "),e("h3",{attrs:{id:"为什么要进行dns域名解析？解析规则是什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么要进行dns域名解析？解析规则是什么？"}},[t._v("#")]),t._v(" 为什么要进行dns域名解析？解析规则是什么？")]),t._v(" "),e("p",[t._v("1 因为网络标准规定了URL只能是字母和数字以及一些特数字符组成；特殊字符包含（-_.~ ! * ' ( ) ; : @ & = + $ , / ? # [ ]）。而且如果不转义会出现歧义，比如http:www.baidu.com?name=zhangsan,假如我的name本身就包括等于=符号，比如n=ame=zhangsan，就会出现歧义，你不知道=到底是连接key和zhangsan的符号，还是说本身key里面就有=")]),t._v(" "),e("h3",{attrs:{id:"大佬接着毒打我说，那url编码的规则是什么呢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#大佬接着毒打我说，那url编码的规则是什么呢"}},[t._v("#")]),t._v(" 大佬接着毒打我说，那url编码的规则是什么呢?")]),t._v(" "),e("p",[t._v("utf-8")]),t._v(" "),e("h3",{attrs:{id:"大佬接着穷追不舍，为啥是utf-8呢，所有浏览器都是这样吗？中文的话用gb2312编码吗，还有就是万一浏览器不是你说的这样统一用utf-8，你怎么保证都是utf-8的编码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#大佬接着穷追不舍，为啥是utf-8呢，所有浏览器都是这样吗？中文的话用gb2312编码吗，还有就是万一浏览器不是你说的这样统一用utf-8，你怎么保证都是utf-8的编码"}},[t._v("#")]),t._v(" 大佬接着穷追不舍，为啥是utf-8呢，所有浏览器都是这样吗？中文的话用gb2312编码吗，还有就是万一浏览器不是你说的这样统一用utf-8，你怎么保证都是utf-8的编码?")]),t._v(" "),e("p",[t._v("应该和html本身的编码格式有关，然后怎么保证utf-8的编码，我觉得可以用encodeURIComponent")]),t._v(" "),e("p",[t._v("如果 Url 是采用 gb2312 来编码的，用户点击时，浏览器自然可以通过网页的字符集来正确解码 Url。 但当我把这个 Url 复制粘帖到浏览器的地址栏， 浏览器没法知道它的编码格式是 gb2312")]),t._v(" "),e("p",[t._v("url参数是发送到服务器的，由网站后台来解析参数， 后台认定是gb2312了，就不管怎么提交上来都按gb2312来解码\n一般网站都只认一种    有的网站会自动识别编码(识别也不能保证100%准确)")]),t._v(" "),e("p",[t._v("大部分浏览器是utf-8，360浏览器就有编码自动检测功能，如果出现乱码能手动调整")]),t._v(" "),e("h3",{attrs:{id:"encodeuricomponent比encodeuri有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#encodeuricomponent比encodeuri有什么区别"}},[t._v("#")]),t._v(" encodeURIComponent比encodeURI有什么区别?")]),t._v(" "),e("p",[t._v("encodeURIComponent编码范围更广，适合给参数编码，encodeURI适合给URL本身（locaion.origin）编码,当然项目里一般都是用qs库去处理")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",[t._v("dns解析流程，并且html如何做dns优化")])]),t._v(" "),e("p",[t._v("比如说查询一个网址为：www.baidu.com\n1、器中输入https://www.baidu.com 域名，操作系统会先查hosts件是否有记录，有的话就会把相对应映射的IP返回。\n2、hosts文件没有就去查本地dns解析器有没有缓存。\n3、然后就去找我们计算机上配置的dns服务器上有或者有缓存，就返回\n4、还没有的话就去找根DNS服务器(全球13台，固定ip地址)，然后判断.com域名是哪个服务器管理，如果无法解析，就查找.baidu.com服务器是否能解析，直到查到www.baidu.com的IP地址")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",[t._v("dns查询有两种模式，一种是转发模式，一种是非转发模式")])]),t._v(" "),e("p",[t._v("上面4种是非转发模式。")]),t._v(" "),e("h3",{attrs:{id:"前端的dns优化，可以在html页面头部写入dns缓存地址，比如"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端的dns优化，可以在html页面头部写入dns缓存地址，比如"}},[t._v("#")]),t._v(" 前端的dns优化，可以在html页面头部写入dns缓存地址，比如")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<meta http-equiv="x-dns-prefetch-control" content="on" />\n<link rel="dns-prefetch" href="http://bdimg.share.baidu.com" />\n')])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br")])]),e("h3",{attrs:{id:"查找到ip之后，就是http协议的三次握手（以及后面会涉及到四次分手）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#查找到ip之后，就是http协议的三次握手（以及后面会涉及到四次分手）"}},[t._v("#")]),t._v(" 查找到IP之后，就是http协议的三次握手（以及后面会涉及到四次分手）")]),t._v(" "),e("p",[t._v("为啥是三次握手而不是2次握手？")]),t._v(" "),e("p",[t._v("第一次握手：主机A发送位码为SYN＝1的TCP包给服务器，并且随机产生一个作为确认号（这是tcp包的一部分），主机B收到SYN码后直到A要求建立连接;")]),t._v(" "),e("p",[t._v("第二次握手：主机B收到请求后，向A发送确认号（主机A的seq+1），syn=1，seq = 随机数 的TCP包；")]),t._v(" "),e("p",[t._v("主机A收到后检查确认号是否正确，即第一次A发送的确认号是否+1了，以及位码ack是否为1，若正确，主机A会再发送确认号(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。")]),t._v(" "),e("p",[t._v("因为第二次握手，主机B还不能确认主机A已经收到确认请求，也是说B认为建立好连接，开始发数据了，结果发出去的包一直A都没收到，那攻击B就很容易了，我专门发包不接收，服务器很容易就挂了。")]),t._v(" "),e("h3",{attrs:{id:"从网卡把数据包传输出去到服务器发生了什么？osi参考模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从网卡把数据包传输出去到服务器发生了什么？osi参考模型"}},[t._v("#")]),t._v(" 从网卡把数据包传输出去到服务器发生了什么？OSI参考模型")]),t._v(" "),e("p",[t._v("先从局域网把数据发送到公司的交换机（如果交换机没有缓存本地mac地址和IP地址的映射，此时会通过ARP协议来获得），交换机的好处是可以隔离冲突域（因为以太网用的是CSMA/CD协议,这个协议规定网线上同一时刻只能有一台机器发送数据），这样就可以不仅仅同一时刻只有一台机器发送网络包了")]),t._v(" "),e("p",[t._v("然后交换机再将数据发送到路由器，路由器相当于公司网关（我们公司小），路由器具有转发和分组数据包的功能（路由器通过选定的路由协议会构造出路由表，同时不定期的跟相邻路由器交换路由信息），然后这算是经过了物理层，数据链路层（以太网）,开始到网络层进行数据转发了")]),t._v(" "),e("p",[t._v("然后路由器转发IP数据报，一般公司的IP地址都会经过NAT转换，让内网的ip也能够访问外网，我们公司我注意了一下是192.168打头的内网ip地址。通过路由器的分组传输，所有数据到达服务器。")]),t._v(" "),e("p",[t._v("然后服务器的上层协议传输层协议开始发挥作用，根据tcp包里的端口号，让服务器特定的服务来处理到来的数据包，并且tcp是面向字节流的(tcp有四大特性，可靠传输、流量控制、拥塞控制、连接管理)，所以我们node的request对象，它的监听事件data事件为什么要用字符串一起拼接起来呢（buffer），就是因为tcp本身就是字节流，request对象使用的data（http层面）是tcp传来的数据块。")]),t._v(" "),e("p",[t._v("最后数据由传输层转交给应用层，也就是http服务（或者https），后端经过一系列逻辑处理，返回给前端数据。")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",[t._v("建立完链接，就该请求html文件了，如果html文件在缓存里面浏览器直接返回，如果没有，就去后台拿")])]),t._v(" "),e("h3",{attrs:{id:"请解释一下浏览器请求缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请解释一下浏览器请求缓存"}},[t._v("#")]),t._v(" 请解释一下浏览器请求缓存")]),t._v(" "),e("p",[t._v("浏览器首次加载资源成功时，服务器返回200，此时浏览器不仅将资源下载下来，而且把response的header(里面的date属性非常重要，用来计算第二次相同资源时当前时间和date的时间差)一并缓存;")]),t._v(" "),e("p",[t._v("下一次加载资源时，首先要经过强缓存的处理，cache-control的优先级最高，比如cache-control：no-cache,就直接进入到协商缓存的步骤了，如果cache-control：max-age=xxx,就会先比较当前时间和上一次返回200时的时间差，如果没有超过max-age，命中强缓存，不发请求直接从本地缓存读取该文件（这里需要注意，如果没有cache-control，会取expires的值，来对比是否过期），过期的话会进入下一个阶段，协商缓存")]),t._v(" "),e("p",[t._v("协商缓存阶段，则向服务器发送header带有If-None-Match和If-Modified-Since的请求，服务器会比较Etag，如果相同，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200;")]),t._v(" "),e("p",[t._v("协商缓存第二个重要的字段是，If-Modified-Since，如果客户端发送的If-Modified-Since的值跟服务器端获取的文件最近改动的时间，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200;")]),t._v(" "),e("h3",{attrs:{id:"什么是from-disk-cache和from-memory-cache吗，什么时候会触发？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是from-disk-cache和from-memory-cache吗，什么时候会触发？"}},[t._v("#")]),t._v(" 什么是from disk cache和from memory cache吗，什么时候会触发？")]),t._v(" "),e("p",[t._v("强缓存会触发")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",[t._v("1、先查找内存，如果内存中存在，从内存中加载；\n2、如果内存中未查找到，选择硬盘获取，如果硬盘中有，从硬盘中加载；\n3、如果硬盘中未查找到，那就进行网络请求；\n4、加载到的资源缓存到硬盘和内存；")])]),t._v(" "),e("h3",{attrs:{id:"什么是启发式缓存吗，在什么条件下触发？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是启发式缓存吗，在什么条件下触发？"}},[t._v("#")]),t._v(" 什么是启发式缓存吗，在什么条件下触发？")]),t._v(" "),e("p",[t._v("如果响应中未显示Expires，Cache-Control：max-age或Cache-Control：s-maxage，并且响应中不包含其他有关缓存的限制，缓存可以使用启发式方法计算新鲜度寿命。通常会根据响应头中的2个时间字段 Date 减去 Last-Modified 值的 10% 作为缓存时间。")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("  // Date 减去 Last-Modified 值的 10% 作为缓存时间。\n  // Date：创建报文的日期时间, Last-Modified 服务器声明文档最后被修改时间\n  response_is_fresh =  max(0,（Date -  Last-Modified)) % 10\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br")])]),e("p",[t._v("返回html之后，会解析html,cssom + domTree = html,然后布局和绘制")]),t._v(" "),e("p",[t._v("构建DOM树(DOM tree)：从上到下解析HTML文档生成DOM节点树（DOM tree），也叫内容树（content tree）；")]),t._v(" "),e("p",[t._v("构建CSSOM(CSS Object Model)树：加载解析样式生成CSSOM树；")]),t._v(" "),e("p",[t._v("执行JavaScript：加载并执行JavaScript代码（包括内联代码或外联JavaScript文件）；\n构建渲染树(render tree)：根据DOM树和CSSOM树,生成渲染树(render tree)；")]),t._v(" "),e("p",[t._v("渲染树：按顺序展示在屏幕上的一系列矩形，这些矩形带有字体，颜色和尺寸等视觉属性。\n布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置；")]),t._v(" "),e("p",[t._v("绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过UI后端模")])])}),[],!1,null,null,null);a.default=r.exports}}]);