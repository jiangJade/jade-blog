(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{576:function(t,s,e){"use strict";e.r(s);var _=e(4),a=Object(_.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"_1-什么是socket"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是socket"}},[t._v("#")]),t._v(" 1 什么是socket")]),t._v(" "),e("p",[t._v("在计算机通信领域，socket被译为'套接字'，他是计算机之间进行通信的一种约定或一种方式。通过socket这种约定，一台计算机可以接收其他计算机的数据。它可以向其他计算机发送数据。")]),t._v(" "),e("p",[t._v("socket起源于Unix, 而Unix/Linux基本哲学之一就是'一切皆文件'，都可以用于'open--\x3e读写write/red--\x3e关闭close'模式来操作。")]),t._v(" "),e("p",[t._v("我的理解就是：socket就是该模式的一个实现。即socekt是一种特殊的文件，一些socket函数就是对其进行的操作（读/写、打开、关闭)\nSocket()函数返回一个整形的socket描述符，随后的连接建立，数据传输等操作都是通过核心socket实现的。")]),t._v(" "),e("h2",{attrs:{id:"_2-网络进程如何通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-网络进程如何通信"}},[t._v("#")]),t._v(" 2 网络进程如何通信")]),t._v(" "),e("p",[t._v("既然Socket主要是用来解决网络通信的，那么我们就来理解网络中进程是如何通信的。")]),t._v(" "),e("h3",{attrs:{id:"（1）本地进程间通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#（1）本地进程间通信"}},[t._v("#")]),t._v(" （1）本地进程间通信")]),t._v(" "),e("p",[t._v("a.消息传递(管道、消息队列、FIFO)")]),t._v(" "),e("p",[t._v("b.同步(互斥量、条件变量、读写锁、文件和写记录锁、信号量)")]),t._v(" "),e("p",[t._v("c.共享内存")]),t._v(" "),e("p",[t._v("d.远程过程调用(RPC)")]),t._v(" "),e("h3",{attrs:{id:"_2-网络中进程如何通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-网络中进程如何通信"}},[t._v("#")]),t._v(" (2)网络中进程如何通信")]),t._v(" "),e("p",[t._v("我们要理解网络中进程如何通信，得解决两个问题：\na.我们要如何标识一台主机，即怎样确定我们将要通信的进程是在那一台主机上运行。\nb.我们要如何标识唯一进程，本地通过pid标识，网络中应该怎样标识\n解决方法：")]),t._v(" "),e("p",[t._v("a.Tcp/Ip协议族已经帮我们解决了这个问题，网络层的ip地址可以唯一标识网络中的主机。")]),t._v(" "),e("p",[t._v("b.传输层的协议+端口就可以标识主机中的应用程序(进程)，因此，我们利用三元组（ip,协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其他进程进行交互")]),t._v(" "),e("h2",{attrs:{id:"３、socket怎么通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#３、socket怎么通信"}},[t._v("#")]),t._v(" ３、Socket怎么通信")]),t._v(" "),e("p",[t._v("现在，我们知道了网络中进程间如何通信，即利用三元组【ip地址，协议，端口】可以进行网络间通信了，那我们应该怎么实现了，因此，我们socket应运而生，它就是利用三元组解决网络通信的一个中间件工具，就目前而言，几乎所有的应用程序都是采用socket，如UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰）。\nSocket通信的数据传输方式，常用的有两种：\n　　ａ、SOCK_STREAM：表示面向连接的数据传输方式。数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送，但效率相对较慢。常见的 http 协议就使用 SOCK_STREAM 传输数据，因为要确保数据的正确性，否则网页不能正常解析。\n　　ｂ、SOCK_DGRAM：表示无连接的数据传输方式。计算机只管传输数据，不作数据校验，如果数据在传输中损坏，或者没有到达另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。因为 SOCK_DGRAM 所做的校验工作少，所以效率比 SOCK_STREAM 高。\n　　例如：QQ 视频聊天和语音聊天就使用 SOCK_DGRAM 传输数据，因为首先要保证通信的效率，尽量减小延迟，而数据的正确性是次要的，即使丢失很小的一部分数据，视频和音频也可以正常解析，最多出现噪点或杂音，不会对通信质量有实质的影响")]),t._v(" "),e("h3",{attrs:{id:"４、tcp-ip协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#４、tcp-ip协议"}},[t._v("#")]),t._v(" ４、TCP/IP协议")]),t._v(" "),e("p",[t._v("4.1、概念\nTCP/IP【TCP（传输控制协议）和IP（网际协议）】提供点对点的链接机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。它将软件通信过程抽象化为四个抽象层，采取协议堆栈的方式，分别实现出不同通信协议。协议族下的各种协议，依其功能不同，被分别归属到这四个层次结构之中，常被视为是简化的七层OSI模型。")]),t._v(" "),e("p",[t._v("它们之间好比送信的线路和驿站的作用，比如要建议送信驿站，必须得了解送信的各个细节。")]),t._v(" "),e("p",[t._v("TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后还要断开连接，客户端在收发数据前要使用 connect() 函数和服务器建立连接。建立连接的目的是保证IP地址、端口、物理链路等正确无误，为数据的传输开辟通道。\nTCP建立连接时要传输三个数据包，俗称三次握手（Three-way Handshaking）。可以形象的比喻为下面的对话：")])])}),[],!1,null,null,null);s.default=a.exports}}]);